---
aliases:
  - Refactoring
tags:
  - SoftwareDev
  - incomplete
"References:": 
cssclasses: 
sr-due: 2024-05-02
sr-interval: 17
sr-ease: 274
---
# Intro:
Refactoring is the process of making the code cleaner and easier to use. 

We’ll see and understand that refactoring main goal is not Quality, Clean Code, professionallity or Moral reasons. But **economic benefits** 
# Types of refactoring: 

## Litter-Pickup refactoring: 
Litter pickup refactoring is the process we follow when the code is so dirty that it cannot be understood or properly used. This refactoring focuses on cleaning the code
## Comprehension Refactoring: 
This refactoring focuses on making the code easier to be understood.
## Opportunistic refactoring: 
This type of refactoring is based on when is someone looking at dirty code. If a developer founds dirty code that is in need of refactor, it’ll be on his judgement whether it needs to be refactored or not: 
![[Screenshot 2024-04-09 at 17.22.56.png]]
## Preparatory refactoring: 
This refactoring is done when **adding a new feature**. If during this process the developer sees that the existing structures are not what it’s needed, the restructure of the system is called preparatory refactoring. As it better fits the code for future features. 

## Planned refactoring:

## Long-term refactoring: 

# The cost of refactoring: 
Without good code design, features will be created really fast at first. However with time the process will slow down, as the code will be dirtier every time. 
Implementation of a better design will make it easier to find the desired code and understand the next features that need to be implemented. 

When comparing the designs of dirty code vs clean code and their time consumed for development we can see that: 
+ At first it may be faster to do no refactor, with no design. 
+ However there is a point from which 
## Benefits of refactoring: 

## Problems with refactoring: 
## Do not refactor if:

+ If it’s better to just rewrite from scratch instead

+ When the current code just **does not work**

+ **When close to a deadline**. 
	The productivity gain from refactoring would appear after the deadline and thus be too late. 
# When to refactor:


# Refactoring process:
## Green - red cycle
Applying refactoring to the [[20240501 - 124636 - Equivalent test classes|TDD]] programming flow: The green-red cycle: 
![[Screenshot 2024-04-09 at 17.17.43.png]]

This cycle focuses on making things work, then 

## Algorithm for refactoring:

1. Identify where refactoring needs to take place: 
	+ Difficulties to understand the code
	+ New features
	+ Improving the efficiency
	+ Known refactor situations
	
2. IF there are **test cases, pass the test cases**. ELSE: Write all test cases and pass them 
	1. <font color="#ff0000">Do not start anything before test cases are passed</font>
		+ For softwares like pyBuilder this means having a successful build
3. Find the adequate type of [[#Types of refactoring]]
4. After each step execute a test
5. If required create new test cases or adapt the ones there already exist.
6. **When finished with the refactor:** Run all test, integrate the code (git merge), run test again
